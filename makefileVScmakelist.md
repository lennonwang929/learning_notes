**Makefile** 和 **CMakeLists.txt** 都用于构建 C++ 项目，但它们有一些关键的区别，主要体现在其设计理念、功能、使用方式以及灵活性上。下面我们详细比较这两者：

### 1. **构建系统 vs. 构建配置**

-   **Makefile**：`Makefile` 是一个构建系统的配置文件，直接描述了项目的构建规则、依赖关系、编译选项、目标文件以及如何从源代码生成可执行文件或库。它由 **`make`** 工具读取并执行。
-   **CMakeLists.txt**：`CMakeLists.txt` 是 **CMake** 构建工具的配置文件，用于描述项目的构建规则。CMake 本身并不是构建工具，它会根据 `CMakeLists.txt` 生成特定平台的构建文件（例如 Makefile、Visual Studio 项目文件、Xcode 工程文件等），然后由相应的构建工具（如 `make`、`ninja` 或 IDE）来执行构建。

**总结**：

-   `Makefile` 直接控制构建过程。
-   `CMakeLists.txt` 用于生成其他构建工具（如 Makefile、Visual Studio 工程文件等）的配置文件。

----------

### 2. **平台和跨平台支持**

-   **Makefile**：`Makefile` 是平台依赖的。虽然 `make` 工具本身是跨平台的，但 `Makefile` 文件通常需要针对不同操作系统进行调整（例如 Windows 上的 `make` 和 Linux 上的 `make`，甚至不同的编译器选项和路径）。
-   **CMakeLists.txt**：CMake 本身是跨平台的，CMake 可以生成针对不同平台（Windows、Linux、macOS）的构建文件。CMake 通过 `CMakeLists.txt` 生成适合当前平台和编译器的构建文件，无需手动修改文件。

**总结**：

-   `Makefile` 更依赖于特定平台，适合小规模、单一平台的项目。
-   `CMakeLists.txt` 旨在支持跨平台开发，可以生成适用于多个平台的构建文件。

----------

### 3. **易用性和灵活性**

-   **Makefile**：`Makefile` 的语法非常简单和直接，但它的灵活性也较低。构建规则和依赖关系必须手动管理，复杂项目时可能需要非常庞大和复杂的 Makefile。尤其是处理大型项目或跨平台构建时，手写的 Makefile 会非常麻烦。
-   **CMakeLists.txt**：CMake 作为一个生成构建系统的工具，提供了比 `Makefile` 更强大的抽象。你只需要在 `CMakeLists.txt` 中描述项目结构，CMake 会根据平台和编译器生成相应的构建文件。这使得 `CMakeLists.txt` 更加灵活，适用于复杂和跨平台的项目，尤其是在涉及多个依赖或多平台构建时。

**总结**：

-   `Makefile` 简单、直接，但对于复杂项目和跨平台支持不够灵活。
-   `CMakeLists.txt` 更加灵活和可扩展，适合复杂项目，尤其是跨平台项目。

----------

### 4. **功能和特性**

-   **Makefile**：
    
    -   主要提供编译、链接和构建规则的控制。
    -   每个目标的构建规则需要手动指定，并且如果项目结构变化，`Makefile` 可能需要手动更新。
    -   支持的特性有限，例如无法直接处理平台差异和第三方依赖的管理，通常需要自己去维护。
-   **CMakeLists.txt**：
    
    -   CMake 提供了很多内置功能，例如查找库 (`find_package`)、设置编译选项、设置安装规则、管理多项目和子项目等。
    -   CMake 可以自动处理平台差异（例如 Windows 和 Unix-like 系统的差异），并且可以更容易地管理复杂的依赖关系。
    -   CMake 支持导入和使用第三方库，并且有丰富的模块和工具来简化跨平台构建。
    -   CMake 可以生成各种构建系统的配置文件（如 Makefile、Ninja、Visual Studio、Xcode 等），让你使用适合的构建工具。

**总结**：

-   `Makefile` 提供了基本的功能，适合小型项目。
-   `CMakeLists.txt` 提供更丰富的功能，适合大规模、复杂或跨平台的项目。

----------

### 5. **跨平台和工具链**

-   **Makefile**：在跨平台项目中，`Makefile` 需要显式地定义不同平台的规则和工具链。例如，你需要手动指定不同操作系统下的编译器和编译选项。
-   **CMakeLists.txt**：CMake 自动处理跨平台问题。你只需要指定项目的依赖关系和构建选项，CMake 会根据目标平台和编译器自动生成相应的构建文件，并处理平台差异。

**总结**：

-   `Makefile` 在跨平台构建时需要更多的手动配置。
-   `CMakeLists.txt` 自动处理跨平台问题，提供更好的工具链支持。

----------

### 6. **配置和使用的复杂度**

-   **Makefile**：`Makefile` 是一个构建系统的脚本，所有的依赖关系、编译规则和链接规则都需要开发者手动编写。对于简单项目非常有效，但对于复杂项目而言，维护起来比较繁琐。
-   **CMakeLists.txt**：CMake 提供了一个抽象层，简化了构建配置的复杂度，尤其在处理复杂的依赖关系、第三方库、跨平台构建时，CMake 提供的工具和模块可以显著降低工作量。

**总结**：

-   `Makefile` 更直接、简洁，但适合小型或简单的项目。
-   `CMakeLists.txt` 更抽象、自动化，适合中型和大型项目，特别是跨平台项目。

----------

### 7. **依赖管理**

-   **Makefile**：依赖管理通常需要手动指定，并且在复杂项目中可能容易出错。例如，源文件的变化可能需要手动更新 Makefile 中的依赖规则。
-   **CMakeLists.txt**：CMake 提供了更强的依赖管理功能，包括自动查找库、自动检测编译器和平台、自动处理依赖项的链接等。例如，CMake 可以自动处理通过 `find_package()` 查找到的库和工具链。

**总结**：

-   `Makefile` 需要手动管理依赖，尤其是大型项目时，依赖管理较为繁琐。
-   `CMakeLists.txt` 提供更自动化的依赖管理，特别适用于处理外部库和跨平台依赖。

----------

### 总结：**Makefile** vs. **CMakeLists.txt**

特性

**Makefile**

**CMakeLists.txt**

**目的**

直接描述构建过程和规则

生成特定平台的构建系统文件

**平台支持**

平台依赖，需要手动调整

跨平台，自动生成对应平台的构建文件

**功能**

基本的编译、链接规则，功能较少

丰富的功能，支持复杂项目、第三方库、跨平台等

**复杂度**

对于复杂项目需要手动管理和维护

提供抽象层，简化复杂项目的构建过程

**灵活性**

高，适合小型项目，但管理复杂项目时较困难

灵活，适合跨平台和复杂项目，自动化程度高

**依赖管理**

手动管理，容易出错

自动管理，支持外部库查找和自动链接

**简而言之**：

-   **Makefile**：适用于简单的项目，直接且灵活，但对于跨平台和复杂依赖的项目不够方便。
-   **CMakeLists.txt**：适用于跨平台和复杂项目，提供更高层次的抽象和自动化，减少了手动管理和平台差异的麻烦。
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTkxNzI4NjU0XX0=
-->