

## 两种方式实现删除元素

### 1:保证顺序
```cpp
class Solution { 
public: int removeElement(vector<int>& nums, int val) { int slow=0; for(int i=0;i<nums.size();i++){ if(nums[i]!=val){ 
nums[slow]=nums[i]; 
slow++; } 
} 
return slow; } 
};
```
### 2:不保证顺序，效率更高
```cpp
class  Solution {

public:

int  removeElement(vector<int>&  nums, int  val) {

int left=0;

int right=nums.size()-1;

while(left<=right){

if(nums[left]==val){

nums[left]=nums[right];

right--;

}else{

left++;

}

}

return left;

}

};
```
与方法一不同的是，**方法二避免了需要保留的元素的重复赋值操作**。
快慢双指针一个有趣的解读
```cpp
int removeElement(int* nums, int numsSize, int val) { 
int slow = 0, fast = 0; //一对夫妇，原本都是零起点 
while (fast < numsSize) { //但是有一个跑得快，一个跑得慢 
if (nums[fast] != val) { //于是跑得快的那个先去寻找共同目标 
nums[slow] = nums[fast]; //如果找到了，就送给跑得慢的那个 
slow++; //然后跑得慢的那个也就离目标近一点 
} 
fast++; //但是不管是否找得到，跑得快的那方都一直奔跑到生命的尽头 
} 
return slow; //最终留下跑得慢的一方 
}
```
双指针技术是一种常用的算法策略，广泛应用于数组和链表等数据结构的处理。它的基本思想是使用两个指针在一个数据结构上进行操作，通常用于简化问题、提高效率或解决特定类型的问题。以下是对双指针技术的详细介绍。

### 双指针的基本概念

1. **定义**：双指针技术使用两个指针（通常称为 `left` 和 `right`）同时遍历数据结构，以达到特定的目的。指针可以在数组、链表或其他线性数据结构上移动，配合不同的条件实现特定功能。

2. **用途**：双指针技术可以用于多种场景，包括：
   - 移除或查找元素
   - 合并或分割数据
   - 寻找满足特定条件的子数组或子序列

### 双指针的类型

1. **对撞指针**（Two-pointer Technique）
   - **描述**：两个指针从数据结构的两端向中间移动。常用于排序数组、查找特定值等。
   - **示例**：
     - 反转字符串
     - 在排序数组中查找两个数的和等于目标值

2. **快慢指针**（Floyd's Tortoise and Hare）
   - **描述**：一个指针（慢指针）每次移动一步，另一个指针（快指针）每次移动两步。常用于链表循环检测和寻找链表的中间节点。
   - **示例**：
     - 判断链表是否有环
     - 找到链表的中间节点

3. **滑动窗口**（Sliding Window）
   - **描述**：在一维数组上维护一个窗口的左右边界，动态调整窗口大小。常用于求解子数组的最大或最小值等问题。
   - **示例**：
     - 找到数组中和为某个值的连续子数组
     - 最小覆盖子串

### 双指针的常见应用

1. **移除元素**：
   - 题目：给定一个数组和一个值，移除所有该值的元素，返回新数组的长度。
   - 方法：使用两个指针，一个遍历整个数组，另一个指向新数组的有效位置。

   ```cpp
   int removeElement(vector<int>& nums, int val) {
       int left = 0;  // 有效位置
       for (int right = 0; right < nums.size(); right++) {
           if (nums[right] != val) {
               nums[left] = nums[right];
               left++;
           }
       }
       return left;  // 返回新数组的长度
   }
   ```

2. **合并两个有序数组**：
   - 题目：合并两个有序数组为一个新的有序数组。
   - 方法：使用两个指针分别指向两个数组的当前元素，比较大小并填入结果数组。

   ```cpp
   void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
       int i = m - 1, j = n - 1, k = m + n - 1;  // 指针初始化
       while (i >= 0 && j >= 0) {
           if (nums1[i] > nums2[j]) {
               nums1[k--] = nums1[i--];
           } else {
               nums1[k--] = nums2[j--];
           }
       }
       while (j >= 0) {  // 处理剩余元素
           nums1[k--] = nums2[j--];
       }
   }
   ```

3. **寻找目标和**：
   - 题目：在排序数组中找到两个数的和等于目标值。
   - 方法：使用对撞指针，从两端向中间移动。

   ```cpp
   vector<int> twoSum(vector<int>& nums, int target) {
       int left = 0, right = nums.size() - 1;
       while (left < right) {
           int sum = nums[left] + nums[right];
           if (sum == target) {
               return {nums[left], nums[right]};
           } else if (sum < target) {
               left++;
           } else {
               right--;
           }
       }
       return {};  // 未找到
   }
   ```

### 优点

1. **提高效率**：双指针技术通常能将时间复杂度降低到 O(n)，相较于暴力算法的 O(n^2) 具有显著优势。

2. **减少空间使用**：许多双指针问题可以在原地进行修改，降低了空间复杂度。

3. **简化逻辑**：通过将问题分解为两个部分，双指针往往能够使逻辑更加清晰，代码更加易于维护。

### 总结

双指针技术是一种非常有效的算法策略，适用于多种问题，尤其是在处理数组和链表时。掌握双指针的使用方法和适用场景能够帮助你更高效地解决许多常见的编程问题。

时间复杂度和空间复杂度是评估算法性能的两个重要指标。它们帮助我们理解算法在不同输入规模下的表现。以下是对时间复杂度和空间复杂度的详细说明，以及如何分析它们。

### 时间复杂度

**定义**：时间复杂度是衡量算法执行所需时间的函数，通常用大O符号表示，表示算法的运行时间相对于输入规模 \( n \) 的增长率。

**常见时间复杂度类型**：

1. **O(1)**：常数时间复杂度。无论输入规模如何，执行时间保持不变。
   - 示例：访问数组中的一个元素。

2. **O(log n)**：对数时间复杂度。常见于二分查找等算法。
   - 示例：在有序数组中查找元素。

3. **O(n)**：线性时间复杂度。随着输入规模的增加，执行时间线性增长。
   - 示例：遍历数组。

4. **O(n log n)**：常见于高效的排序算法（如归并排序和快速排序）的时间复杂度。
   - 示例：归并排序。

5. **O(n²)**：平方时间复杂度。通常出现在嵌套循环中。
   - 示例：冒泡排序和选择排序。

6. **O(2^n)** 和 **O(n!)**：指数时间复杂度和阶乘时间复杂度，通常用于解决 NP 完全问题。
   - 示例：某些递归算法，如求解斐波那契数列的朴素递归版本。

### 空间复杂度

**定义**：空间复杂度是衡量算法在执行过程中所需额外空间的函数，通常用大O符号表示，表示算法所需空间相对于输入规模 \( n \) 的增长率。

**常见空间复杂度类型**：

1. **O(1)**：常数空间复杂度。算法只使用固定的额外空间。
   - 示例：在原地交换两个变量的值。

2. **O(n)**：线性空间复杂度。所需空间随着输入规模线性增长。
   - 示例：存储输入数组的副本或在递归中使用的栈空间。

3. **O(n²)**：平方空间复杂度。通常用于需要存储二维数组的情况。
   - 示例：在动态规划中使用的二维 DP 表。

### 如何分析时间复杂度和空间复杂度

1. **确定基本操作**：
   - 找到算法中的基本操作（如比较、赋值、循环迭代等），并确定这些操作的执行次数。

2. **分析循环**：
   - 对于简单循环，时间复杂度通常是 O(n)；对于嵌套循环，时间复杂度通常是 O(n²) 或更高。
   - 如果循环的范围随着输入规模的增长而变化，考虑用公式来表示。

3. **分析递归**：
   - 使用递归树或主定理来分析递归算法的时间复杂度。
   - 识别递归的深度和每层的工作量。

4. **考虑额外空间**：
   - 确定算法在执行过程中使用了多少额外空间（如临时变量、数据结构、递归栈等）。

### 示例分析

以之前提到的移除元素的算法为例：

```cpp
int removeElement(vector<int>& nums, int val) {
    int slow = 0;  
    for (int fast = 0; fast < nums.size(); fast++) {
        if (nums[fast] != val) {
            nums[slow] = nums[fast];  
            slow++;  
        }
    }
    return slow;  
}
```

- **时间复杂度**：
  - 这个算法的核心是一个循环，遍历数组一次，因此时间复杂度是 O(n)，其中 n 是数组的大小。

- **空间复杂度**：
  - 这个算法只使用了常数空间（几个变量），没有使用额外的数据结构，因此空间复杂度是 O(1)。

### 总结

通过理解和分析时间复杂度和空间复杂度，可以更好地评估和优化算法的性能。在解决问题时，尽量寻找最优的时间和空间复杂度组合，以提升算法的整体效率。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE0NDc0MTAzNTgsMjAxMTA0NDMxM119
-->